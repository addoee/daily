#### 闭包

**闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放**

##### 一.作用域

作用域我们可以理解是在这个范围内有权限可以访问的变量，当然它可以有很多个

* 全局作用域

  当我们通过``var a = 1`` 定义一个变量，它就是一个全局变量，在这个范围内容不管什么地方我们都可以直接使用这个变量。

* 函数作用域

  我们通过在函数下定义一个变量：

  ```function
  function foo(){
    var a = 1;
  }
  ```

  如果我们在函数外部访问这个变量是访问不到的。这个函数内部的变量只能在这个函数内部使用，当然包括它的子函数。

我们暂时就先记住全局和函数作用域，继续往下寻找知识点深入。

##### 二.LHS和RHS

* LHS:Left-Hand-Side
* RHS：Right-Hand-Side

当编译器在工作时，会检测是否申明过一个变量，没有的话就在当前作用域声明变量。接下来引擎协同作用域通过LHS和RHS来查询是否有过引用。

LHS查询和RHS查询，这里我们可以简单的理解为赋值的左侧和右侧，但它并不仅仅是赋值“=”的左侧和右侧，还有其他等同于赋值的操作，如参数的传递。我们可以将其理解为“谁是赋值的目标（LHS）"、”谁是赋值的源（RHS）“。

``var a = 1``  这个简单的语句，对a的引用是LHS引用，也就是赋值的目标a，我们实际不关心它的值。但是``console.log(a)`` 这里对a的引用就是RHS引用，因为这个操作我们是需要取它的源头的值，所以它就是RHS。

在一段代码中，LHS和RHS都是在当前作用域开始查找，如果没有找到它会一层一层向上查找，直到全局作用域为止。不同的是，LHS如果到了全局作用域都没有找到对这个变量的引用，它用隐式的创建一个全局变量。RHS则会提示``ReferenceError`` 错误。

##### 三.变量提升

###### 提升

这个可不陌生，我小菜鸡都知道的这个点。

```a
a = 1
var a
console.log(a) //1
```

JavaScript虽然是解释性的语言，代码会从一行执行到另一行，但是这不是完全正确的。

浏览器在运行代码时会对代码进行编译分析，对的，JavaScript也是需要编译的，它会在编译时找到我们代码中所有的变量声明和函数声明。但是它仅仅是找到声明，并不会处理赋值操作，赋值操作会出现在执行阶段。

如``var a=1``  在编译时编译器只会找到``var a`` 。正如上面的代码一样，虽然定义``var a`` 在第二行，但是在编译器编译是它会先找到，然后在执行过程中被赋值。这个就是我们所说的变量提升。

我们可以验证下面的代码，就能更好的理解为什么仅仅是声明。

```var a =1
console.log(a)  //undefined
var a = 1
```

###### **函数优先**  

```
foo()
var foo
function foo(){
  console.log(1)
}
foo = function(){
  console.log(2)
}
```

理解上面的代码，我们定义foo ，并且还定义了一个函数，编译器会优先将函数提升到最前面，也就是我们定义的foo函数，其次才会变量。所以记住函数声明会提升到普通变量之前。

##### 四.垃圾回收机制

当我们通过js定义一个变量时，系统自动为我们分配了内存来存放这个变量。我们可以通过这个变量来做其他操作。当变量使用完成后，需要对这个变量指向的内存地址进行释放。这也就是所谓的垃圾回收。

> 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它[原型](https://developer.mozilla.org/en-US/JavaScript/Guide/Inheritance_and_the_prototype_chain)的引用（隐式引用）和对它属性的引用（显式引用）。

* 引用计数垃圾回收

最初的垃圾回收算法通过简单的”有没有对象引用它“来验证是否需要进行回收。

```
function foo(){
  var a = {}
  var b = {}
  a.name = b
  b.age = a //他们之间互相引用
  return "x"
}
```

上面代码中a和b之间互相引用，在函数调用完成以后实际已经可以回收了，但是引用计数会认为它们之间至少还有一次引用，所以不会被回收。

* 标记清楚算法

通过从全局查找引用的对象及对象引用的对象，查找到所有可以获得的对象和不可获得的对象。通过标记它们来进行回收，所有从全局中无法查询到的对象都将被清除。

#####五.闭包

> 当函数可以记住并访问词法作用域时，就产生了闭包，即使函数是在当前作用域之外执行。

```
function foo(){
  var a = 1
  return function(){
    console.log(a)
  }
}
var bar = foo()
bar()
```

当我们定义了一个foo函数，并在其内部直接返回了一个匿名函数。本来我们在函数内部可以直接定义一个新的函数并执行它，也是可以输出a的值，但是并没有这样做，而是将foo这个函数赋值给了bar，它实际赋值的是匿名foo（）之后返回的哪个匿名函数，当我们再运行bar（）时，就直接在定义的foo函数作用域之外访问到了a这个数值。

按照垃圾回收的机制，var a = 1 这个变量在引用完成以后实际应该被回收的，但是显然，闭包阻止了它，我们在foo中返回的这个匿名函数在引用着这个函数内的作用域，它使得在后续代码中也可以继续使用使用。

现在我们可以试着理解第一句引用的话，返回的匿名函数赋值给了bar，它在函数当前的作用域以外执行了，并且这个匿名函数还是在引用的之前的作用域。

